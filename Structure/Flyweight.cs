using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Structure
{
    namespace Flyweight
    {
    }
}

/*
Паттерн Приспособленец (Flyweight) - структурный шаблон проектирования, который позволяет использовать
разделяемые объекты сразу в нескольких контекстах. Данный паттерн используется преимущественно для оптимизации
работы с памятью.

В качестве стандартного применения данного паттерна можно привести следующий пример.
Текст состоит из отдельных символов. Каждый символ может встречаться на одной странице текста много раз.
Однако в компьютерной программе было бы слишком накладно выделять память для каждого отдельного символа 
в тексте. Гораздо проще было бы определить полный набор символов, например, в виде таблицы
из 128 знаков (алфавитно-цифровые символы в разных регистрах, знаки препинания и т.д.).
А в тексте применить этот набор общих разделяемых символов, вместо сотен и тысяч объектов, которые могли бы 
использоваться в тексте. И как следствие подобного подхода будет уменьшение количества используемых объектов
и уменьшение используемой памяти.


Паттерн Приспособленец следует применять при соблюдении всех следующих условий:
 - Когда приложение использует большое количество однообразных объектов, из-за чего происходит выделение
    большого количества памяти

 - Когда часть состояния объекта, которое является изменяемым, можно вынести во вне.
    Вынесение внешнего состояния позволяет заменить множество объектов небольшой группой общих
    разделяемых объектов.

Ключевым моментом здесь является разделение состояния на внутренне и внешнее.
Внутреннее состояние не зависит от контекста. В примере с символами внутреннее состояние описывается кодом
символа из таблицы кодировки. Так как внутреннее состояние не зависит от контекста, то оно может быть
разделяемым и поэтому выносится в разделяемые объекты.

Внешнее состояние зависит от контекста, является изменчивым. В применении к символам внешнее состояние может 
представлять положение символа на странице. То есть код символа может быть использован многими символами,
тогда как положение на странице будет для каждого символа индивидуально.

При создании приспособленца внешнее состояние выносится. В приспособленце остается только внутреннее
состояние. То есть в примере с символами приспособленец будет хранить код символа.

    class FlyweightFactory
    {
        Hashtable flyweights = new Hashtable();
        public FlyweightFactory()
        {
            flyweights.Add("X", new ConcreteFlyweight());
            flyweights.Add("Y", new ConcreteFlyweight());
            flyweights.Add("Z", new ConcreteFlyweight());
        }
        public Flyweight GetFlyweight(string key)
        {
            if (!flyweights.ContainsKey(key))
                flyweights.Add(key, new ConcreteFlyweight());
            return flyweights[key] as Flyweight;
        }
    }
 
    abstract class Flyweight
    {
        public abstract void Operation(int extrinsicState);
    }
 
    class ConcreteFlyweight : Flyweight
    {
        int intrinsicState;
        public override void Operation(int extrinsicState)
        {
        }
    }
 
    class UnsharedConcreteFlyweight : Flyweight
    {
        int allState;
        public override void Operation(int extrinsicState)
        {
            allState = extrinsicState;
        }
    }
 
    class Client
    {
        void Main()
        {
            int extrinsicstate = 22;
 
            FlyweightFactory f = new FlyweightFactory();
 
            Flyweight fx = f.GetFlyweight("X");
            fx.Operation(--extrinsicstate);
 
            Flyweight fy = f.GetFlyweight("Y");
            fy.Operation(--extrinsicstate);
 
            Flyweight fd = f.GetFlyweight("D");
            fd.Operation(--extrinsicstate);
 
            UnsharedConcreteFlyweight uf = new UnsharedConcreteFlyweight();
 
            uf.Operation(--extrinsicstate);
        }
    }


Flyweight: определяет интерфейс, через который приспособленцы-разделяемые объекты могут получать внешнее
состояние или воздействовать на него

ConcreteFlyweight: конкретный класс разделяемого приспособленца.
Реализует интерфейс, объявленный в типе Flyweight, и при необходимости добавляет внутреннее состояние.
Причем любое сохраняемое им состояние должно быть внутренним, не зависящим от контекста

UnsharedConcreteFlyweight: еще одна конкретная реализация интерфейса, определенного в типе Flyweight,
только теперь объекты этого класса являются неразделяемыми

FlyweightFactory: фабрика приспособленцев - создает объекты разделяемых приспособленцев.
Так как приспособленцы разделяются, то клиент не должен создавать их напрямую. 
Все созданные объекты хранятся в пуле. В примере выше для определения пула используется объект Hashtable,
но это не обязательно. Можно применять и другие классы коллекций. Однако в зависимости от сложности структуры,
хранящей разделяемые объекты, особенно если у нас большое количество приспособленцев, то может увеличиваться 
время на поиск нужного приспособленца - наверное это один из немногих недостатков данного паттерна.

Если запрошенного приспособленца не оказалось в пуле, то фабрика создает его.

Client: использует объекты приспособленцев. Может хранить внешнее состояние и передавать его в качестве
аргументов в методы приспособленцев

*/
